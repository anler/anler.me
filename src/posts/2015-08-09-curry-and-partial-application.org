---
title: Curry and Partial Application. Know the difference!
---

** The problem

I've seen people referring to partial application as /currying/, specially people in the Groovy community since in that language the function used for partial application is named *curry*.

Partial application in action using Groovy:

#+BEGIN_SRC groovy
  def addition = {a, b -> a + b}  // function of two arguments
  def addTwo = addition.curry(2)  // fix first argument
  println addTwo(2)               // result: 4
#+END_SRC

The problem strikes at line: =addition.curry(2)= where it's calling *curry* to the operation of *partial application*.

Let's read the definitions of each of them.

** Partial application.

#+BEGIN_QUOTE
In computer science, partial application (or partial function application) refers to the process of fixing a number of arguments to a function, producing another function of smaller arity.

Given a function:

\scriptstyle f \colon (X \times Y \times Z) \to N

we might fix (or 'bind') the first argument, producing a function of type:

\scriptstyle\text{partial}(f) \colon (Y \times Z) \to N

Evaluation of this function might be represented as f_{partial}(y, z) instead of the original function f(x, y, z).

-- Wikipedia
#+END_QUOTE

** Currying

#+BEGIN_QUOTE
Given a function f of type:

\scriptstyle f \colon (X \times Y) \to Z

currying it makes a function curry(f) of type:

\scriptstyle \text{curry}(f) \colon X \to (Y \to Z)

That is, \scriptstyle \text{curry}(f) takes an argument of type \scriptstyle X and returns a function of type \scriptstyle Y \to Z .

-- Wikipedia
#+END_QUOTE

** Both side by side

So, partial application can be seen as a higher-order function that receives a function with some arguments and returns a function with those arguments fixed, let's pretend it's type is something like:

#+BEGIN_SRC text
  partial: NAryFunction → [Argument] → NAryFunction
#+END_SRC

looking at it from the typed point of view we can state that partial application of an n-ary function is another n-ary function with =length [Argument]= less arguments.

On the other hand currying can be seen as a higher-order function that receives an n-ary function and returns an unary function, let's pretend it's type is something like:

#+BEGIN_SRC text
  curry :: NAryFunction → UnaryFunction1 → UnaryFunction2 → ... → UnaryFunctionN
#+END_SRC

So it transforms a multi-argument function in a function of one argument that returns another function of one argument and so on until all the arguments are supplied. Another way of looking at it is as serie of nested closures:

#+BEGIN_SRC javascript
  // JavaScript
  function(a) {
      return function(b) {
          return function(c) {
              return a + b + c;
          };
      };
  }

  // Or in modern JavaScript
  (a) => (b) => (c) => a + b + c;
#+END_SRC

So as you can see from their *pretended* type signatures, they are completely different!

Generally what we found in most languages is partial application and in the face of partial application currying is probably not needed because is akward to use in most imperative languages (because of the repeated function-calling syntax), take for example this snippet of JavaScript:

#+BEGIN_SRC javascript
  //
  // curry and partial are fictional functions
  //
  let addition        = (a, b) => a + b,
      additionCurried = curry(addition);

  // with partial application you can do more than one thing
  // that is, you can fix how many arguments you need.
  let addTwo = partial(addition, 2),
      four   = partial(addition, 2, 2);

  // with currying on the other hand you have only one way
  // which is give the function an argument at a time.
  let addTwo = additionCurried(2),
      four   = additionCurried(2)(2);
#+END_SRC

See it from this point of view, a function =f= can be partially applied using two techniques:

1. Partially apply the function directly: =partial(f, [args...])=
2. Curryfy the function: =curry(f)= which obligates you to supply the rest of the arguments one-by-one

In most languages the first option is preferred because syntactically looks better and lets you fix more than one argument at a time.

** The beauty of Haskell

One of the things I like most from Haskell is its syntax, which is funny because I used to hate it and favor Lisp syntax (or lack of it :P). Haskell doesn't have partial application, but currified functions, but thanks to Haskell syntax where function evaluation doesn't need any special notation the use of curried functions looks just as partial application. Take for example the following:

#+BEGIN_SRC haskell
  addition a b = a + b

  addTwo = addition 2

  four = addition 2 2
#+END_SRC

I want you to pay special attention to this line ~four = addition 2 2~, here =addition= is a curried function that cannot receive more than one argument at a time, but with Haskell's syntax that's transparent, it looks just as partial application, what's really happening though is that Haskell sees that expression as =(addition 2) 2=, in other words, it calls =addition= with the argument =2= and calls again its result =(addition 2)= with the argument =2=. This is contrary to what we see in other languages where functions and values are clearly separated and there is special syntax for evaluating a function. Take for example the same snippet of code in JavaScript:

#+BEGIN_SRC javascript
  let addition = curry((a, b) => a + b),
      addTwo   = addition(2),
      four     = addition(2)(2);
#+END_SRC

Here you see that since =four= is curried we are obligated to give it all its arguments one-by-one and because of JavaScript's syntax the process looks kind of awkard =addition(2)(2)= compared to partial application =partial(addition, 2, 2)=.

** Some drops of history

The name /Currying/ was given by [[https://en.wikipedia.org/wiki/Christopher_Strachey][Christopher Strachey]] as a reference to [[https://en.wikipedia.org/wiki/Haskell_Curry][Haskell Brooks Curry]], an American logician known for his work in combinatory logic.

The /currying/ technique was actually invented by [[https://en.wikipedia.org/wiki/Moses_Sch%25C3%25B6nfinkel][Moses Schönfinkel]], a Russian logician who was the /inventor/ of combinatory logic, and it was a simplification to the work done in combinatory logic and lambda calculus that states that functions of two or more arguments can be replaced by functions taking just one argument.
