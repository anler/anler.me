---
title: Fold you so
---

#+BEGIN_QUOTE
A *higher-order* function is a function that receives a function as a parameter and/or
returns a function as its result.
#+END_QUOTE

The *fold* family of functions apply an operator over a data structure in a single pass. They are present in many languages, sometimes with a different name of such as *reduce*.

Depending on how the operation is grouped when traversing the list there are two variants of a fold:

1. fold-right (foldr) where the operation groups to the right.
2. fold-left (foldl) where the operation groups to the left.

** Foldr

Let's start with the simplest one and take a look to the following functions:

#+BEGIN_SRC haskell
  sum' xs = head xs + sum' (tail xs)
  sum' [] = 0

  product' xs = head xs * product' (tail xs)
  product' [] = 1
#+END_SRC

Can you spot a common pattern in those functions? Can you spot the differences with this:

#+BEGIN_SRC haskell
  f xs = head xs ⊕ f (tail xs)
  f [] = v
#+END_SRC

Correct! there are no differences! So, wouldn't be nice that we abstracted the previous functions pattern? Well, we can do that with the function *foldr*:

#+BEGIN_SRC haskell
  f = foldr ⊕ v
#+END_SRC

Visually, applying foldr to a list looks like this:

#+BEGIN_SRC text
  foldr ⊕ v [x1, x2, ..., xn] = x1 ⊕ (x2 ⊕ (...(xn ⊕ v)...))
#+END_SRC

now you should have a clue on why it is called =foldr= because it groups the operations to the right.
Using it, we can re-implement the above functions in this way:

#+BEGIN_SRC haskell
  sum' = foldr (+) 0

  product' = foldr (*) 1
#+END_SRC

Now, let's see the implementation of foldr along with its type signature:

#+BEGIN_SRC haskell
  foldr :: (a -> b -> b) -> b -> [a] -> b
  foldr ⊕ v xs = head xs ⊕ (foldr ⊕ v (tail xs))
  foldr ⊕ v [] = v
#+END_SRC

What conclusions do we can get from it? Let's see:

- =foldr= is a recursive function.
- =v= is used as the result when the list *is empty*.
- =⊕= has to be a binary function (an operator), that's what =a -> b -> b= means.
- =⊕= first parameter is of type =a= so it has to be an element of the list because the list has type =[a]=.
- =⊕= second parameter is of type =b= so it has to be =v= because that's the type of =v=, moreover, its result is also of type =b= which is telling us that the result is used as a new =v=.

Our examples have something else in common, let's first see what's the definition of a *monoid*:

#+BEGIN_QUOTE
In abstract algebra, a branch of mathematics, a monoid is an algebraic structure with a single associative binary operation and an identity element. -- Wikipedia
#+END_QUOTE

In our examples =(+)= is an associative operation and =0= it's its identity element, so they form a monoid. The same happens with =(*)= and =1=.

whenever =⊕= and =v= form a monoid, we can state =foldr= will have the type:

#+BEGIN_SRC haskell
  foldr :: (a -> a -> a) -> a -> [a] -> a
#+END_SRC

** Foldl

We already know about =foldr= and we know it groups the operation to the right, so let's define a =foldl= that instead groups the operation to the left:

#+BEGIN_SRC text
  foldl ⊕ [x1, x2, ..., xn] = ((...(v ⊕ xn)...⊕ x2) ⊕ x1)
  foldl ⊕ []                = v
#+END_SRC

The recursive pattern abstracted by =foldl= looks like this:

#+BEGIN_SRC text
  f v xs = f (v ⊕ head xs) (tail xs)
  f v [] = v
#+END_SRC

So its implementation along with its type signature must be:

#+BEGIN_SRC haskell
  foldl :: (b -> a -> b) -> b -> [a] -> b
  foldl ⊕ v xs = foldl ⊕ (v ⊕ head xs) (tail xs)
  foldl ⊕ v [] = v
#+END_SRC

** Similarities between foldr and foldl

As you have seen =foldr= and =foldl= functions are very similar, in fact, as with =foldr=, when =⊕= and =v= form a monoid we can state its type will be:

#+BEGIN_SRC haskell
  foldl :: (a -> a -> a) -> a -> [a] -> a
#+END_SRC

so in the presence of a monoid =foldr= and =foldl= have both the *same* type. This guides us to what is called the *first duality theorem*:

#+BEGIN_SRC text
  foldl ⊕ v xs = foldr ⊕ v xs
#+END_SRC

whenever =⊕= and =v= form a monoid and =xs= is a finite list.

So our example functions, =sum= and =product=, can be implemented using any of the two because of the *first duality theorem*, and whenever this is the case, using =foldl= is going to result in a more efficient solution since its algorithm is /tail recursive/.
** Remarks

- The /Fold you so/ expression is taken from the amazing book [[http://learnyouahaskell.com/][Learn You a Haskell for Great Good]]
- All the information came from [[http://wikipedia.org][Wikipedia]] and these books: [[http://www.amazon.com/Introduction-Functional-Programming-International-Computing/dp/0134841891?tag%3Dduckduckgo-d-20][Introduction to Functional Programming]] and [[http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695?tag%3Dduckduckgo-d-20][Programming in Haskell]].
