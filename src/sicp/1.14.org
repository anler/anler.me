---
title: SICP: Exercise 1.14
---

Draw the tree illustrating the process generated by the =count-change= procedure in making change for 11 cents. What are the orders of growth of the space and number of steps used by this process as the amount to be changed increases?

Count change procedure implemented in Scheme
#+BEGIN_SRC scheme
  (define (count-change amount)
    (cc amount 5))

  (define (cc amount kinds-of-coins)
    (cond ((= amount 0)
           1)
          ((or (< amount 0)
               (= kinds-of-coins 0))
           0)
          (else (+
                 (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

  (define (first-denomination kinds-of-coins)
    (cond ((= kinds-of-coins 1) 1)
          ((= kinds-of-coins 2) 5)
          ((= kinds-of-coins 3) 10)
          ((= kinds-of-coins 4) 25)
          ((= kinds-of-coins 5) 50)))
#+END_SRC

Count change procedure implemented in Haskell

#+BEGIN_SRC haskell
  countChange a = cc a 5

  cc a n | a == 0 = 1
         | a < 0 || n == 0 = 0
         | otherwise = ccButFirst + ccMinusFirst
    where ccButFirst = cc a (n - 1)
          ccMinusFirst = cc (a - firstDenomination n) n

  firstDenomination n | n == 1 = 1
                      | n == 2 = 5
                      | n == 3 = 10
                      | n == 4 = 25
                      | n == 5 = 50
#+END_SRC

* Solution

The first problem consists in drawing the tree-process generated by the procedure =count-change= applied to 11 cents. I tried to draw it by hand but after a moment it was clear that the task was really long and boring, so as always, I tried to use Haskell to find the solution. The solution takes advantage of the Writer monad to keep a log of each step of the function and later that log is used to write the tree in [[https://en.wikipedia.org/wiki/DOT_%2528graph_description_language%2529][DOT]] format.

The Haskell script is the following:

#+BEGIN_SRC haskell
  {-# LANGUAGE FlexibleContexts #-}
  import Control.Monad.Writer
  import Text.Printf
  import Data.List

  main = printLog . snd $ runWriter $ countChange 11

  countChange a = cc a 5

  cc a n
    | a == 0          = writer (1, [[getLog a n, "1"]])
    | a < 0 || n == 0 = writer (0, [[getLog a n, "0"]])
    | otherwise       =
        let a' = a - firstDenomination n
            n' = n - 1
        in
          do
            tell [[getLog a n, getLog a n']
                 ,[getLog a n, getLog a' n]]
            x <- cc a n'
            y <- cc a' n
            return (x + y)

  firstDenomination n | n == 1 = 1
                      | n == 2 = 5
                      | n == 3 = 10
                      | n == 4 = 25
                      | n == 5 = 50

  getLog a n = printf "\"cc %s %s\"" (show a) (show n)

  printLog log =
      putStrLn $ printf "digraph {\n%s\n}" (intercalate ";\n" edges)
    where edges = map (intercalate " -> ") log
#+END_SRC

The tree can be seen by running =runhaskell script.hs | xdot= and it should look like this:

[[../images/ex1-14.png]]

Here you can easily see the result of =countChange 11= which is =4=, there are four edges pointing to node =1=.
